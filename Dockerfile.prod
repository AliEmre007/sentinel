# ==========================================
# STAGE 1: The Builder (Heavyweight)
# ==========================================
# We use the official Go Alpine image just for compiling.
FROM golang:1.24.0-alpine AS builder

# Set the working directory inside the container
WORKDIR /app

# BEST PRACTICE: Copy go.mod and go.sum first to cache dependencies.
# This makes future builds much faster.
COPY go.mod go.sum ./
RUN go mod download

# Copy the rest of the source code
COPY . .

# BEST PRACTICE: The Production Build Command
# CGO_ENABLED=0: Disables C dependencies, creating a 100% pure, standalone Go binary.
# GOOS=linux: Ensures it is compiled specifically for Linux cloud servers.
# -ldflags="-w -s": Strips out debugging information to make the file size even smaller.
RUN CGO_ENABLED=0 GOOS=linux go build -ldflags="-w -s" -o sentinel-binary .

# ==========================================
# STAGE 2: The Final Image (Featherweight & Secure)
# ==========================================
# BEST PRACTICE: 'scratch' is a completely empty Docker image. 
# It has no OS, no shell, no utilities. It is virtually unhackable.
FROM scratch

# Copy ONLY the compiled binary from the builder stage. 
# The heavy Go compiler and raw source code are left behind and destroyed.
COPY --from=builder /app/sentinel-binary /sentinel-binary

# Document the port the API listens on
EXPOSE 8080

# Run the standalone machine-code binary
ENTRYPOINT ["/sentinel-binary"]
